1. When does the balancer kick in?

A-D below represent four different sharded cluster scenarios. Assuming you are running MongoDB 2.2 or greater, in which of the following scenarios would you expect there to be at least one balancing round to adjust the distribution of chunks across the shards? A is not one of them, by the way, and Adam uses this as a springboard into a little diagnosis in the solution.[See the attached Pic]
A[F] - Total chunks are equal to 20 and difference should be 4 and so no migrations will happen.
B[T] - Less than 20 chunks and difference between them > 2
C[F] - Mote than 80 chunks are difference should be 8 not 3 and so no migrations will happen.
D[T] - More then 80 chunks and difference between them > 8

2. How does the balancer pick chunks?

Suppose the output below reflects a sharded cluster you are working with. Based on the lesson, which chunk will be selected for migration during the next balancing round?
mongos> sh.status({verbose : 1})
--- Sharding Status --- 
sharding version: {
  "_id" : 1,
  "version" : 4,
  "minCompatibleVersion" : 4,
  "currentVersion" : 5,
  "clusterId" : ObjectId("538b744619782a0df0966b77")
}
shards:
  {  "_id" : "shard0000",  "host" : "localhost:30000" }
  {  "_id" : "shard0001",  "host" : "localhost:30001" }
  {  "_id" : "shard0002",  "host" : "localhost:30002" }
  {  "_id" : "shard0003",  "host" : "localhost:30003" }
databases:
  {  "_id" : "admin",  "partitioned" : false,  "primary" : "config" }
  {  "_id" : "myapp",  "partitioned" : true,  "primary" : "shard0001" }
    myapp.users
      shard key: { "email" : 1 }
      chunks:
        shard0000  6
        shard0002  5
        shard0003  6
        shard0001  9
      { "email" : { "$minKey" : 1 } } -->> { "email" : "aa" } on : shard0000 Timestamp(2, 0) 
      { "email" : "aa" } -->> { "email" : "ab" } on : shard0002 Timestamp(3, 0) 
      { "email" : "ab" } -->> { "email" : "ac" } on : shard0003 Timestamp(4, 0) 
      { "email" : "ac" } -->> { "email" : "ad" } on : shard0000 Timestamp(5, 0) 
      { "email" : "ad" } -->> { "email" : "ae" } on : shard0002 Timestamp(6, 0) 
      { "email" : "ae" } -->> { "email" : "ba" } on : shard0003 Timestamp(7, 0) 
      { "email" : "ba" } -->> { "email" : "bb" } on : shard0000 Timestamp(8, 0) 
      { "email" : "bb" } -->> { "email" : "bc" } on : shard0001 Timestamp(9, 0) 
      { "email" : "bc" } -->> { "email" : "bd" } on : shard0003 Timestamp(10, 0) 
      { "email" : "bd" } -->> { "email" : "be" } on : shard0001 Timestamp(11, 0) 
      { "email" : "be" } -->> { "email" : "ca" } on : shard0002 Timestamp(12, 0) 
      { "email" : "ca" } -->> { "email" : "cb" } on : shard0003 Timestamp(13, 0) 
      { "email" : "cb" } -->> { "email" : "cc" } on : shard0000 Timestamp(14, 0) 
      { "email" : "cc" } -->> { "email" : "cd" } on : shard0002 Timestamp(15, 0) 
      { "email" : "cd" } -->> { "email" : "ce" } on : shard0003 Timestamp(16, 0) 
      { "email" : "ce" } -->> { "email" : "da" } on : shard0000 Timestamp(17, 0) 
      { "email" : "da" } -->> { "email" : "db" } on : shard0002 Timestamp(18, 0) 
      { "email" : "db" } -->> { "email" : "dc" } on : shard0003 Timestamp(19, 0) 
      { "email" : "dc" } -->> { "email" : "dd" } on : shard0000 Timestamp(20, 0) 
      { "email" : "dd" } -->> { "email" : "de" } on : shard0001 Timestamp(20, 1) 
      { "email" : "de" } -->> { "email" : "ea" } on : shard0001 Timestamp(1, 41) 
      { "email" : "ea" } -->> { "email" : "eb" } on : shard0001 Timestamp(1, 43) 
      { "email" : "eb" } -->> { "email" : "ec" } on : shard0001 Timestamp(1, 45) 
      { "email" : "ec" } -->> { "email" : "ed" } on : shard0001 Timestamp(1, 47) 
      { "email" : "ed" } -->> { "email" : "ee" } on : shard0001 Timestamp(1, 49) 
      { "email" : "ee" } -->> { "email" : { "$maxKey" : 1 } } on : shard0001 Timestamp(1, 50) 

There should be migration from shard0001 to shard0002 and the chunk with lowest range:
Answers:
{ "email" : { "$minKey" : 1 } } -->> { "email" : "aa" } on : shard0000
{ "email" : "aa" } -->> { "email" : "ab" } on : shard0002
{ "email" : "bb" } -->> { "email" : "bc" } on : shard0001[T]
{ "email" : "db" } -->> { "email" : "dc" } on : shard0003
{ "email" : "ee" } -->> { "email" : { "$maxKey" : 1 } } on : shard0001

3. Anatomy of a migration overview

Get a little practice reading log information on chunk migrations. Spin up a sharded cluster using the shardingTest() helper. Shard a collection across this cluster and create 20 or more chunks. Then look at the config.changelog collection to see how the chunks were moved from one shard to another during balancing.

As values for the "what" field for documents in this collection you will see, "moveChunk.start", "moveChunk.to", and "moveChunk.from". You will also see one other value for the "what" field related to moveChunk operations. What is that value? Please enter the value exactly as it appears in config.changelog documents. Include the double quotes surrounding the value in your answer. - "moveChunk.commit" 

4. While a chunk is in flight, where are updates and inserts for documents in the chunk range routed?

They are not routed, the mongos caches them until the chunk migration completes.
They are routed to the shard the chunk is being migrated from.[T]
They are routed to the shard the chunk is being migrated to.
They are routed to both shards.
They are not routed, clients receive an exception notifying them to retry once migration is complete.

5. Spin up a sharded cluster with three shards. In a database called houses create collections named lannister, stark, and targaryen. Set up your cluster so that the collection representing each house is pinned to one of the shards.
Here is one possible solution to the Game of Thrones problem we posed. Please note that we are passing a configuration document to ShardingTest. This will ensure the mongods are created using small files and without preallocating data files and journal files. It should eliminate problems with disk space that some students have reported when using ShardingTest.

config = { d0 : { smallfiles : "", noprealloc : "", nopreallocj : ""}, d1 : { smallfiles : "", noprealloc : "", nopreallocj : "" }, d2 : { smallfiles : "", noprealloc : "", nopreallocj : ""}};
cluster = new ShardingTest( { shards : config } );
// shard db
sh.enableSharding("houses");

// shard collections
sh.shardCollection("houses.stark", {dire_wolves_owned:1});
sh.shardCollection("houses.lannister", {debt_owed:1});
sh.shardCollection("houses.targaryen", {followers:1});

// Insert sample data
use houses;
var bulk = db.stark.initializeUnorderedBulkOp();

for (var i=0; i < 100000; i++) { bulk.insert({dire_wolves_owned: Math.random()}); }
bulk.execute();
bulk = db.lannister.initializeUnorderedBulkOp();
for (var i=0; i < 100000; i++) { bulk.insert({debt_owed: Math.random()}); }
bulk.execute();
bulk = db.targaryen.initializeUnorderedBulkOp();
for (var i=0; i < 100000; i++) { bulk.insert({followers: Math.random()}); }

bulk.execute();

sh.addShardTag("shard0000", "sta");
sh.addShardTag("shard0001", "lan");
sh.addShardTag("shard0002", "tar");

sh.addTagRange("houses.stark", {dire_wolves_owned:MinKey}, {dire_wolves_owned:MaxKey}, "sta");
sh.addTagRange("houses.lannister", {debt_owed:MinKey}, {debt_owed:MaxKey}, "lan");
sh.addTagRange("houses.targaryen", {followers:MinKey}, {followers:MaxKey}, "tar");

6. In which of the following scenarios would hash-based sharding be most likely to provide performance benefits?

In write-heavy applications[T]
In read-heavy applications
In systems distributed across hardware with varying levels of performance
If the common query patterns in an application select documents based on multiple fields
